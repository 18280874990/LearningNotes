                                                    	JAVA笔记
----------------------------------------------------------------------------------------------------------------------
【第一章】JAVA基本框架
 程序：为了让计算机执行某些操作或解决某个问题，而编写的一系列有序指令的集合。
·JAVA程序框架
    public class 类名{       ---外层框架（类名同文件名）
     public static void main(String[] args){ ---Java入口程序框架
         System.out.println("输出的内容");   ---输出指令     
    }
  }
  main入口四要素：返回值类型、方法名、参数、方法体
  println ---输出内容并执行换行
  print   ---输出内容不执行换行
  \n  ---换行符
  \t  ---制表符(8个空格)

  //注释内容   ---单行注释
   
  /** 	       ---多行注释
   *注释内容  
   */

----------------------------------------------------------------------------------------------------------------------
【第二章】变量、数据类型和运算符
·变量
  变量是存储数据的一个单元。
  语法：
  方法一：
   int money=1000;   ---数据类型 变量名=数值;    //声明变量并赋值

  方法二：
   int money;   ---数据类型 变量名;  //声明变量
   money=1000;  ---变量名=数值;     //赋值

·数据类型
  char   ---字符型（单个字符 如:‘男’）
  int    ---整  型（整数）
  double ---双精度（小数）
  String ---字符串（一串字符 如:"我是Java"）
  boolean ---布尔型   返回值：true真、false 假

  变量名命名规则：
      首字母：字母、下划线‘_’、‘$’符号
      其余部分：数字、字母、下划线‘_’、‘$’符号

·运算符
  语法：
    赋值运算符：=（变量名=表达式;（右→左）
    算数运算符：+（加）、-（减）、*（乘）、/（除）、 %（余）

  类型自动转换：
    在某种条件下，系统自动完成类型转换
     两种类型兼容（如：int和double兼容）
     目标类型大于源类型（如：double型大于int型）
  对于表达式：如果一个操作数为double型，则整个表达式提升为double型。

  类型强制转换：类型 变量名=（类型名）表达式;
	  如：int a=20;
	      double b=9.8;
	      int zh=(int)(a+b);
	      System.out.println(zh);

  i++;   //先执行在加1
  ++i;   //先加1再执行

----------------------------------------------------------------------------------------------------------------------
【第三章】选择结构
·关系运算符
  >（大于）、<（小于）、==（等于）、!=（不等于）、>=（大于等于）、<=（小于等于）

·逻辑运算符
  *******************************************************************
  *  运算符  *     表达式     *               说明                  *
  *  &（且） *  条件1&条件2   *  前者条件为真时，仍然执行后者条件   *
  *  |（或） *  条件1|条件2   *  前者条件为假时，仍然执行后者条件   *
  *  &&      *  条件1&&条件2  *  仅仅两个条件为真，结果为真         *
  *  ||      *  条件1||条件2  *  只要两个条件一个为真，结果为真     *
  *  !（非） *    ！条件      *  条件为真时，结果为假。             *
  *          *                *  条件为假时，结果为真。             *
  *******************************************************************

·基本if选择结构
  if(条件){
    //语句
  }

·if-else选择结构
  if(条件){
    //语句1
  }else{
    //语句2
  }

·if选择结构
  if(条件){
    //语句1
  }else if(条件){
    //语句2
  }else{
    //语句3
  }

·switch选择结构
  switch(条件)
  {
    case 1:
            语句;
            break;
    case 2:
            语句;
            break;
    default:
            语句;
	    break;
   }

·运算符优先级
  最高的优先级：小括号，即()
  最低的优先级：赋值运算符，即=
  优先级顺序：! > 算术运算符 > 比较运算符 > && > ||

·接收数据功能（文本扫描器）
  语法:
   import java.util.Scanner;
   Scanner input=new Scanner(System.in); //声明接收数据功能
   int a=input.nextInt(); //接收输入的内容

	/**
	 * 三元运算符使用实例
	 */
	int i=0;
	//如果i=1字符串s=Yes，否则等于No
	String s=(i==1) ? "Yes":"No";
	System.out.println(s);
----------------------------------------------------------------------------------------------------------------------
【第四章】循环结构（一）
·while循环
  语法：
  while(循环条件){ 
     循环操作
  }
 特点：先判断，再执行。

·do-while循环
  语法：
  do{
     循环操作
  }while(循环条件);
 特点：先执行，再判断。

----------------------------------------------------------------------------------------------------------------------
【第五章】循环结构（二）
·for循环结构
 语法：
  for(表达式1;表达式2;表达式3){   // 表达式1(参数初始化);表达式2（条件判断）;表达式3(更新循环变量)
       循环操作;
  }

·for each循环结构
 作用：用于循环遍历数组、集合
 语法：
  for (类型 变量名 : 源数据变量名) {
	System.out.println(源数据变量名);
  }

·跳转语句
  break;    //跳出循环（用于do-while、while、for中时，可跳出循环而执行循环后面的语句）
  continue; //跳过本次循环
  return;   //结束程序

----------------------------------------------------------------------------------------------------------------------
【第六章】数组
  数组是一个变量，存储相同数据类型的一组数据，数组的下标从0开始。
·语法
 声明数组：
 方法一：
   数据类型 数组名[];
 方法二：
   数据类型[] 数组名;

 声明数组并分配空间：
   数据类型[] 数组名 = new 数据类型[大小];

 赋值：
   数组名[下标] = 数据;

 声明数组批量赋值：
   数据类型[] 数组名 = new 数据类型[]{1,2,3,4,5};

·使用数组步骤
   1、声明数组   int[]a;
   2、分配空间   a=new int[5];
   3、赋值       a[0]=80;
   4、处理数据   a[0]=a[0]*10;

 ·排序输出：
   import java.util.Arrays; // 声明排序功能类包
   public class Test{
   public static void main(String[] args) {
	int [] a=new int[]{3,5,4,1,2}; // 声明数组并赋值
	Arrays.sort(a); // 声明排序功能
	 //循环输出进行1-5升序排列输出
	 for(int i= 0; i<a.length; i++){
		 System.out.print(a[i]+"，"); // 循环输出打印
	 }
    }
  }

  生成随机数
   int max = 9999;//最大值
   int min = 1000;//最小值
   int a=(Math.random()*个数);//生成随机数
  例：
	System.out.print("产生的随机数是：");
		for (int i = 0; i <= 9; i++) {
			int a=(int) (Math.random()*9);
			System.out.print(a+" ");
		}

----------------------------------------------------------------------------------------------------------------------
【第七章】类和对象
·对象同时具有属性和方法两种特性。
  属性：所有对象的公共特征，作用：区分各个对象
  方法：所有对象的公共操作

·类和对象的区别？
  类是对象的抽象，对象是类的具体实例。
  类是抽象的，不占用内存，而对象是具体的，占有内存空间。
  例如：类就是水果，对象就是苹果。

·Java类模板
  public class 类名{
  //定义属性部分
    属性1的类型 属性1;
    属性2的类型 属性2;

  //定义方法部分
    方法1;
    方法2;
   }

·定义一个类的步骤
  1.定义类名
      public class 类名{

      }
  2.编写类的属性
      String name;
  3.编写类的方法
      public String 方法名(){
	   return "姓名："+name";
      }

·如何创建和使用对象
  1.使用new创建类的一个对象
      类名 对象名=new 类名();    Yuntuschool luoyang=new Yuntuschool();
  2.给类的属性赋值：
      对象名.属性=值;    luoyang.name="洛阳";
  3.调用类的方法：
      对象名.方法名();    System.out.println(luoyang.方法名());

----------------------------------------------------------------------------------------------------------------------
【第八章】类的方法（一）
·语法
  public 返回值类型 方法名(){
     //方法体
  }

·返回值类型
  void   //无返回值
  return //有返回值(String int double char boolean)
 
  在同一个类中调用方法可直接调用，在另一个类调用方法要先创建一个类对象然后通过(对象名.方法名)调用方法。
  import 包名.类名;  //调用类
  package 包名;      //声明包
  import 包名;       //导入包

·JavaDoc注释
   JavaDoc注释用于注释类
  语法：
   /**
    * @author 曹帅华
    * @date 2018-4-10 下午6:53:11
    */

----------------------------------------------------------------------------------------------------------------------
【第九章】类的方法（二）
·定义带参数的方法
  访问修饰符 返回值类型 方法名(形参1,形参2,形参...){
        方法的主体
      return 返回值;
  }

·调用带参数的方法
  对象名.方法名(实参1,实参2,实参...);

  实参的名字可以和形参不一样，但是类型、数量、顺序都要与形参一一对应。

----------------------------------------------------------------------------------------------------------------------
【第十章】String字符串
 ·Sring类常用方法
	 ----------------------------------------------------------------------------------------------------
	|返回值类型			方法名				说明			     	     |
	|----------------------------------------------------------------------------------------------------|
	|boolean		equals()	将此字符串与指定的对象比较				     |
	|----------------------------------------------------------------------------------------------------|
  	|int			length()	返回此字符串的长度					     |	
	|----------------------------------------------------------------------------------------------------|
  	|boolean		equalsIgnoreCase(String str)	将此 String 与另一个String比较，不考虑大小写 |
	|----------------------------------------------------------------------------------------------------|
	|String			toUpperCase()	将字符串所有字符都转换为大写  			       	     |
	|----------------------------------------------------------------------------------------------------|
	|String			toLowerCase()	将字符串所有字符都转换为小写  			     	     |
	|----------------------------------------------------------------------------------------------------|
	|String			concat()	将指定字符串连接到此字符串的结尾  			     |
	|----------------------------------------------------------------------------------------------------|
	|String[]		split()		将一个字符串分割为多个子字符串				     |
	|----------------------------------------------------------------------------------------------------|
	|int			indexOf(int ch/String value)	返回指定字符在此字符串中第一次出现处的索引   |
	|----------------------------------------------------------------------------------------------------|
	|int			IastIndexOf(String value)	返回指定字符在此字符串中最后一次出现处的索引 |
	|----------------------------------------------------------------------------------------------------|
	|int			IastIndexOf(int ch)		返回指定字符在此字符串中最后一次出现处的索引 |
	|----------------------------------------------------------------------------------------------------|
	|String			substring(int index)		提取从索引位置开始的字符串		     |
	|----------------------------------------------------------------------------------------------------|
	|String			substring(int beginindex,int endindex) 提取beginindex(包含当前位置)到endindex|
	|							       (不包含当前位置)之间的字符串部分	     |
	|----------------------------------------------------------------------------------------------------|
	|String			trim()					清除字符串两端的空格		     |
	|----------------------------------------------------------------------------------------------------|
	|String			replace(char oldChar,char newChar)	返回一个新的字符串，用newChar替换此字|		|								符串中出现的所有oldChar		     |
	|----------------------------------------------------------------------------------------------------|
 	|boolean		startsWith(String str)			测试此字符串是否以指定的前缀开始     |
	 ----------------------------------------------------------------------------------------------------

·StringBuffer类
  线程安全的可变字符序列
 ·StringBuffer的声明：
   StringBuffer sb=new StringBuffer();   //创建StringBuffer对象
   StringBuffer sb=new StringBuffer("aaa");  //创建一个对象并存储字符串

 ·常用方法
   String toString(): 转换为String类型
   StringBuffer append(): 将指定的字符串追加到此字符序列
   StringBuffer insert (int offset, String str): 将字符串插入到offset位置后的字符序列中

 ·String和StringBuffer/StringBuilder的区别：
	String 长度大小不可变
	StringBuffer 和 StringBuilder 长度可变
	StringBuffer 线程安全 StringBuilder 线程不安全
	StringBuilder 速度快

----------------------------------------------------------------------------------------------------------------------
【第十一章】抽象和封装
 Java语言的三大特性：封装、继承、多态
 ·类图
  ------------------------
 |	    类名	  |
 |------------------------|
 |+属性名:类型 		  |
 |------------------------|
 |+方法名(参数):返回值类型|
  ------------------------
 +public 公共
 -private 私有
 参数：名字:类型,名字:类型

 ·构造函数
	访问修饰符 构造方法名(参数){//构造方法名与类名相同
       	   //初始化代码
	}
 系统会提供默认的无参构造方法，如果自己写了一个自定义构造方法系统将不再提供默认无参构造方法。
 添加构造函数快捷键：
	有参：Shift+Alt+S,选择Generate ... using Fields
	无参：Shift+Alt+S,选择Generate ... Superclass

 方法重载特征：方法名相同；
	       参数项不相同；
	       与返回值、访问修饰符无关；

 ·封装
     将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问
  封装的步骤：
	1.修改属性的可见性 → 设为private
	2.创建公有的getter(获取)/setter(设置)方法 → 用于属性的读写
	3.在getter/setter方法中加入属性控制语句 → 对属性值的合法性进行判断
  添加getter/setter方法的快捷键：Shift+Alt+S,选择Generate ... and Setters

 ·static关键字
  使用static定义变量：
  	static final String NAME="张三";
  	static:静态
  	final:常量(常量名大写,用final修饰的变量成为常量，其值固定不变)

  使用static定义方法：
	static void print(){}
    	Penguin.print();//用类名.方法名()调用

 ·使用面向对象的思想开发程序的好处：
	1.客户和软件设计开发人员之间、软件设计开发人员内部交流更加顺畅
	2.提高软件设计和开发效率

 ·从现实世界抽象出类：
	1.找出名词确定类、属性
	2.找出动词确定方法
	3.剔除与业务无关的属性和方法

 ·static修饰与非static修饰的区别：
	 ------------------------------------------------------------- 
	|	   	|static非private修饰	|非static、private修饰|
	|---------------|-----------------------|---------------------|
	|属性	   	|类属性、类变量		|实例属性、实例变量   |
	|---------------|-----------------------|---------------------|
	|方法	   	|类方法			|实例方法	      |
	|---------------|-----------------------|---------------------|
	|调用方式	|类名.属性		|对象.属性	      |		
	|		|类名.方法()		|对象.方法()          |
	|		|对象.属性		|		      |
	|		|对象.方法()		|		      |
	|---------------|-----------------------|---------------------|
	|归属		|类			|单个对象   	      |
	 ------------------------------------------------------------- 
	注：static可以修饰属性、方法、静态块

----------------------------------------------------------------------------------------------------------------------
【第十二章】继承
  一个父类可以有很多子类，但是一个子类只能有一个父类，子类与父类是is-a关系
 ·优点：方便修改代码，减少代码量
 ·如何使用继承
	1、编写父类
		class Pet {
         	     //公共的属性和方法
		}

	2、编写子类，继承父类(只能继承一个父类)
		class Dog extends Pet {//子类 extends 父类
         	     //子类特有的属性和方法
		}

 ·子类访问父类成员
	（1）使用super关键字，super代表父类对象。
	（2）在子类构造方法中调用且必须是第一句。
	（3）不可以访问父类中定义为private的属性和方法。

 ·访问父类构造方法
	super();//调用父类的无参构造
	super(name); //调用父类的带参构造 super(属性1,属性2,属性3...)

 ·访问父类属性
	super.name;

 ·访问父类方法
	super.print();//super.方法名 调用父类的方法

 ·不能被继承的父类成员
    	1、private成员
	2、子类与父类不在同包，使用默认访问权限的成员
	3、构造方法

  访问修饰符protected：可以修饰属性和方法，本类、同包、子类可以访问。

 ·访问修饰符
   -----------------------------------
  |访问修饰符	 |本类 |同包|子类|其他|
  |--------------|-----|----|----|----|
  |private	 |√   |    |    |    |
  |默认(friendly)|√   |√  |    |    |
  |protected	 |√   |√  |√  |    |
  |public	 |√   |√  |√  |√  |
   -----------------------------------
  private 私有的、friendly 友好的、protected 受保护、public 公开

 ·多重继承关系的初始化顺序
	父类属性→父类构造方法→子类属性→子类构造方法

  符合is-a关系的设计使用继承，继承是代码重用的一种方式，将子类共有的属性和行为放到父类中
  
 ·方法重写规则：
	1.方法名相同
	2.参数列表相同
	3.返回值类型相同或者是其子类
	4.访问权限不能严于父类

 ·方法重载与方法重写区别：
 	|	  |位置	|方法名	|参数表	|返回值		|访问修饰符      |
	|方法重写 |子类	|相同	|相同	|相同或是其子类 |不能比父类更严格|
	|方法重载 |同类	|相同	|不相同	|无关		|无关            |

 ·抽象类
	1.抽象类不能实例化
	2.抽象类中不一定有抽象方法，但抽象方法必须在抽象类中，
	3.抽象方法必须在每个子类中重写
	4.“子类重写”正好解决抽象方法的实例化问题
	5.非抽象类必须重写父类的所有抽象方法

   定义一个抽象类：
	public abstract class A{
		
	}

 ·抽象方法
	1.抽象方法没有方法体
	2.抽象方法必须在抽象类里
	3.抽象方法必须在子类中被实现，除非子类是抽象类

   定义一个抽象方法：
	public abstract void print();

   final 最终的，其值是固定不变的

----------------------------------------------------------------------------------------------------------------------
【第十三章】多态
  同一个引用类型，使用不同的实例而执行不同操作
  好处:多态可以减少类中代码量，提高代码的可扩展性和可维护性
  ·使用多态实现思路
	1.编写父类编写子类，子类重写父类方法
	2.运行时，使用父类的类型，子类的对象
    实现多态的两个要素：子类重写父类方法、使用父类的类型,子类的对象

  ·实现多态的两种形式
	1.将父类作为方法形参实现
	2.将父类作为方法返回值实现

  ·向上转型(子类转换为父类，自动进行类型转换)
	Pet pet = new Dog(); 自动类型转换

  ·向下转型(父类转换为子类，结合instanceof运算符进行强制类型转换)
	Pet p = new Dog("欧欧", "雪娜瑞");
	Dog d = (Dog)p;//将父类p转换为Dog类
	Penguin png = (Penguin) pet;//×父类必须指向真实的子类类型

  ·instanceof运算符
    用来在运行时指出对象是否是特定类的一个实例
    语法：
	对象 instanceof 类或接口
	注：instanceof通常和强制类型转换结合使用

----------------------------------------------------------------------------------------------------------------------
【第十四章】接口
 ·使用接口步骤：
  1.编写接口(interface)：
	public interface Usb{
	    public void lianjie();//所有方法都是抽象方法
	}

  2.实现接口(implements)：
	public class Upan implements Usb {//多个接口使用,分隔 
    	    public void lianjie() {
                System.out.println("已连接USB");
    	    }
	}

  3.使用接口：
	Usb u = new Upan();
	u.lianjie();

 ·接口特性：
	1、接口不可以被实例化
	2、子类必须实现接口的所有方法
	3、子类可以实现多个接口
	4、接口中的变量都是静态常量
	5、接口中所有方法都是抽象的公共的

  抽象类利于代码复用，接口利于代码维护
  实现类和接口是has-a的关系

 ·接口比抽象类更好的特性：
	1.可以被多继承
	2.设计和实现完全分离
	3.更自然的使用多态
	4.更容易搭建程序框架
	5.更容易更换实现

 ·面向接口编程：
	程序设计时面向接口的约定(方法+名称)而不考虑具体实现

----------------------------------------------------------------------------------------------------------------------
【第十五章】异常
   异常是指在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序
	input.hasNextInt(); //判断下一个接收的值是否是整数
	System.exit(1);  //终止程序

 ·异常处理：
   通过5个关键字来实现：try、catch、 finally、throw、throws
 	------------------------------------------------------------------------
 	|	     捕获异常		 |       声明异常        |  抛出异常   |
 	|--------------------------------|-----------------------|-------------|
 	|     try→ 执行可能产生	 |	throws		 |   throw     |
 	|	     异常的代码 	 |	  ↓		 |     ↓      |
 	| 				 |    声明方法可能要	 |手动抛出异常 |
 	|				 |    抛出的各种异常	 |	       |
 	|--------------------------------|			 |	       |
 	|   catch→ 捕获异常 		 |			 |	       |
 	|--------------------------------|			 |	       |
 	| finally→ 无论是否发生异常，代 |			 |	       |
 	|           码总能执行           |			 |	       |		                	------------------------------------------------------------------------

 ·捕获异常
	try {
	      // 代码段(此处不会产生异常)
	} catch (异常类型1 ex) {
	      // 对异常进行处理的代码段
	} catch (异常类型2 ex) {
	      // 对异常进行处理的代码段
		return;
	} finally {
	      
	}
	//代码段

	finally:
	1、是否发生异常都执行
	2、System.exit(1);情况下不执行
	
  	System.err.println();//打印错误信息
  	e.printStackTrace();//调用方法输出异常信息

 ·异常对象常用的方法
	 -----------------------------------------------------------------------------------
	|	方法名		|			说    明			    |
	|-----------------------|-----------------------------------------------------------|
	|void printStackTrace()	|输出异常的堆栈信息					    |
	|String getMessage()	|返回异常信息描述字符串，是printStackTrace()输出信息的一部分|
	 -----------------------------------------------------------------------------------

 ·常见的异常类型
	 -----------------------------------------------------------------------
	|         异 常 类 型	  	|	       说    明			|
	|-------------------------------|---------------------------------------|
	|Exception 			|异常层次结构的父类			|
	|ArithmeticException		|算术错误情形，如以零作除数		|
	|ArrayIndexOutOfBoundsException	|数组下标越界				|
	|NullPointerException		|尝试访问 null 对象成员			|
	|ClassNotFoundException		|不能加载所需的类			|
	|IllegalArgumentException	|方法接收到非法参数			|
	|ClassCastException		|对象强制类型转换出错			|
	|NumberFormatException		|数字格式转换异常，如把"abc"转换成数字	|
	|InputMismatchException		|输入的数据类型与所需类型不匹配异常	|
	 -----------------------------------------------------------------------

 ·抛出异常
	public static void a() throws Exception {//多个异常逗号隔开
		  //可能出现异常的代码
	}
	throw new Exception("");//自定义手动抛出异常

 ·面试题：
	·try-catch块中存在return语句，是否还执行finally块，如果执行，说出执行顺序
	   答：是，try-catch-finally执行顺序：
	   1.执行try{}块
	   2.如果try{}块有异常产生，执行catch{}块
	   3.无论有没有异常都要执行finally{}块，这里可以看出只要finally中有return，必然返回finally{}中的return

	·try-catch- finally块中，finally块唯一不执行的情况是什么？
	   答：当你在捕获到异常的处理代码里加上：System.exit();时不执行

	·说出5个常见的运行时异常
	   答：见上面异常类型

	·throw与throws的区别是什么？
	   答：throw是语句抛出异常，throws是方法可能抛出异常的声明。

 ·开源日志记录工具log4j
	日志(log)：
		主要用来记录系统运行中一些重要操作信息
		便于监视系统运行情况，帮助用户提前发现和避开可能出现的问题，或者出现问题后根据日志找到原因

	日志分类：
		SQL日志、异常日志、业务日志

	log4j是一个非常优秀的开源日志记录工具：
		控制日志的输出级别
		控制日志信息输送的目的地是控制台、文件等
		控制每一条日志的输出格式

     	控制日志输出级别：
		fatal:致命的
     		      ↓
		error:错误消息
	 	      ↓
		warn:警告信息
		      ↓
		info:一般消息
		      ↓
		debug:调试消息
		      ↓
		    自定义

  	使用log4j记录日志步骤：
		1.在项目中加入log4j的JAR文件
		2.创建log4j.properties文件
		3.配置日志信息：
			1、输出级别
			2、日志输出目的地Appender
			3、日志布局类型Layout
			4、转换模式ConversionPattern
		4.使用log4j记录日志信息：
			private static Logger logger=Logger.getLogger（类名.class）
			logger.输出级别("错误描述")

----------------------------------------------------------------------------------------------------------------------
【第十六章】集合框架
   Java集合框架提供了一套性能优良、使用方便的接口和类位于java.util包中
 ·接口
	     	     Collection					Map
	          	 ↑					↑
	       -----------------------			 ---------------
              |		              |			|		|
             List                    Set	     HashMap	      HashMap
	      ↑                     ↑
	   -----------		    -------
          |	      |		   |	   |
      ArrayList  LinkedList     HashSet TreeSet

	集合接口：
		Collection 接口存储一组不唯一，无序的对象
		List 接口存储一组不唯一，有序（插入顺序）的对象
		Set 接口存储一组唯一，无序的对象
		Map 接口存储一组键值对象，提供key到value的映射
    	集合实现类：
		ArrayList 实现了长度可变的数组，在内存中分配连续的空间。遍历元素和随机访问元素的效率比较高				LinkedList 采用链表存储方式。插入、删除元素率比较高

 ·List接口
  ·ArrayList集合类
    创建ArrayList集合对象：
	ArrayList<存储元素的数据类型> 对象名 = new ArrayList<存储元素的数据类型>();

   ·List接口常用方法
    ----------------------------------------------------------------------------------------------------------
   |		方法名		   |					说明				      |
   |-------------------------------|--------------------------------------------------------------------------|
   |boolean add(Object o)	   |在列表的末尾顺序添加元素，起始索引位置从0开始			      |
   |void add(int index,Object o)   |在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间	      |	
   |int size()		    	   |获取列表中的元素个数						      |
   |Object get(int index)	   |获取指定索引位置处的元素,取出的元素是Object类型,使用前需要进行强制类型转换|
   |boolean contains(Object o)     |判断列表中是否存在指定元素						      |
   |boolean remove(Object o)       |从列表中删除元素							      |	
   |Object  remove(int index)      |从列表中删除指定位置元素，起始索引位置从0开始			      |
    ----------------------------------------------------------------------------------------------------------
  ·LinkedList集合类
   ·LinkedList的特殊方法
    ------------------------------------------------------------------------------
   |		方法名		   |			说明			  |
   |-------------------------------|----------------------------------------------|
   |void  addFirst(Object o)	   |在列表的首部添加元素			  |
   |void  addLast(Object o)	   |在列表的末尾添加元素		       	  |
   |Object  getFirst()		   |返回列表中的第一个元素			  |
   |Object  getLast()		   |返回列表中的最后一个元素			  |
   |Object  removeFirst()	   |删除并返回列表中的第一个元素		  |
   |Object  removeLast()	   |删除并返回列表中的最后一个元素		  |
    ------------------------------------------------------------------------------
   ·集合框架的好处：
　　	1.容量自增长。
　　	2.提供有用的数据结构和算法，从而减少编程工作。
　　	3.提高了程序速度和质量，因为它提供了高性能的数据结构和算法。
　　	4.允许不同API之间的互操作，API之间可以来回传递集合。
　　	5.可以方便地扩展或改写集合。

 ·Map接口
   专门处理键值映射数据的存储，可以根据键实现对值的操作
  ·Map接口常用方法
    -------------------------------------------------------------------------------------
   |		方法名		      |			      说明		     	 |
   |----------------------------------|--------------------------------------------------|
   |Object put(Object key,Object val) |以“键-值对”的方式进行存储			 |
   |Object get(Object key)	      |根据键返回相关联的值,如果不存在指定的键，返回null |
   |Object remove (Object key)	      |删除由指定的键映射的“键-值对”			 |
   |int size()			      |返回元素个数					 |
   |Set keySet ()		      |返回键的集合					 |
   |Collection values ()	      |返回值的集合					 |
   |boolean containsKey(Object key)   |如果存在由指定的键映射的“键-值对”,返回true	 |
    -------------------------------------------------------------------------------------

 ·迭代器
	通过迭代器Iterator实现遍历
 	       获取Iterator：Collection 接口的iterate()方法
		   Iterator的方法：
			boolean hasNext() //判断是否存在下一个可访问的元素
			Object next()     //返回要访问的下一个元素
	    实例：
		Iterator<String> it=names.iterator();//获取迭代器
		while (it.hasNext()) {//判断是否拥有下一个元素
			String name=it.next();
			System.out.println(name);
		}

	for each(增强型for循环）
	    语法：
		for(元素类型t 元素变量x : 遍历数组或集合对象){
         	
		}

 ·遍历HashMap集合的方法
	//声明并创建HashMap对象
	Map<Integer, String> map=new HashMap<Integer, String>();
	//存储数据
	map.put(1, "张三");
	map.put(2, "李四");
	map.put(3, "王五");
	//遍历集合
	//方法一：values()获取所有值
	Collection<String> c=map.values();
	for (String string : c) {
		System.out.println(c);
	}

	//方法二：keyset()获取所有键
	Set<Integer> s=map.keySet();
	for (Integer integer : s) {
		String name=map.get(integer);
		System.out.println(name);
	}

	//方法三：entrySet()获取键值映射的set图
	Set<Entry<Integer, String>> s=map.entrySet();
	for (Entry<Integer, String> entry : s) {
		System.out.println(entry.getKey()+" "+entry.getValue());
	}

 ·泛型集合
   好处：类型安全、消除强制类型转换、提高性能
	//创建泛型
	class Dog<T> {
	    //属性
	    private T name;
	    //方法
	    ......
	}
	//使用泛型
	Dog<String> d=new Dog<String>("多多");//<类型>内指定的数据类型

----------------------------------------------------------------------------------------------------------------------
【第十七章】JDBC(Java数据库连接)
 JDBC用于与数据库建立连接、执行SQL语句、处理结果的Java API,集成在java.sql和javax.sql包中。
 ·JDBC使用步骤
	1.加载MySQL驱动程序
	  Class.forName("com.mysql.jdbc.Driver");

	2.建立数据库连接Connection
	  Connection conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/myschool?characterEncoding=utf-		  8","root","123456");

	3.创建statement/PreparedStatement对象，用来发送sql语句，并得到返回的结果
	  PreparedStatement pstate=conn.prepareStatement("SELECT * FROM student where id =?");
	  pstate.setInt(1, 10);
	  ResultSet rs=pstate.executeQuery(); 

	4.处理结果
	  while(rs.next()){
		String sno=rs.getString("sno");
		String sname=rs.getString("sname");
		int age=rs.getInt("sage");
		String sex=rs.getString("ssex");
		System.out.println("学号:"+sno+",姓名:"+sname+"，年龄:"+age+"，性别:"+sex);
	  }

	5.释放资源
	  释放资源顺序: ResultSet → Statement → Connection
	  rs.close();
	  pstate.close();
	  conn.close();

 ·DriverManager类
    作用：依据数据库的不同，管理JDBC驱动
    ·Driver接口
	加载MySql驱动：Class.forName("com.mysql.jdbc.Driver");
	加载Oracle驱动：Class.forName("oracle.jdbc.driver.OracleDriver");

 ·Connection接口
    作用：负责连接数据库并担任传送数据的任务
    ·连接MySql数据库
     Connection conn = DriverManager.getConnection("jdbc:mysql://主机名:端口号/数据库名?参数名=参数                  值,"user","password");
     其他参数：
	localhost:3306	 本地主机地址
	characterEncoding=utf8  设置编码格式

    ·常用方法
      -----------------------------------------------------------------------
     |	    方法名				 说  明			     |
     |-----------------------------------------------------------------------|
     |createStatement()        创建向数据库发送sql的statement对象	     |
     |-----------------------------------------------------------------------|
     |prepareStatement(sql)    创建向数据库发送预编译sql的PrepareSatement对象|
      -----------------------------------------------------------------------

 ·Statement接口
    作用：由 Connection 产生、负责执行SQL语句
    ·常用方法
      -------------------------------------------------------------------------------
     | 	       方法名			                     说 明		     |
     |-------------------------------------------------------------------------------|
     |ResultSet executeQuery(String sql)   执行SQL查询并获取到ResultSet对象（结果集）|
     |-------------------------------------------------------------------------------|
     |int executeUpdate(String sql)	   执行插入、删除、更新操作，返回更新的行数  |
     |-------------------------------------------------------------------------------|
     |boolean execute(String sql) 	   执行任意SQL语句,然后获得一个布尔值，表示是|
     |				   	   否返回ResultSet（结果集）		     |
      ------------------------------------------------------------------------------- 

 ·PreparedStatement接口
    作用：继承自Statement接口，由preparedStatement创建用于发送含有一个或多个参数的SQL语句，比Statement效率更高,     并且可以防止SQL注入，一般都使用PreparedStatement。
    语法：
	一个“?”代表设置一个通配符，下标从1开始
	PreparedStatement pstate=prepareStatement(sql);
	pstate.setString(通配符下标, 值); 

    示例：
	PreparedStatement pstate=null;
 	pstate=conn.prepareStatement("SELECT * FROM `user` WHERE zhanghao=? AND mima=?;");
	pstate.setString(1, "admin");
	pstate.setString(2, "123456");

 ·ResultSet接口
    作用：负责保存Statement执行后所产生的查询结果
    ·常用方法
      -----------------------------------------------------------------------------
     |		方法名				         说 明			   |
     |-----------------------------------------------------------------------------|
     |boolean next()			  将光标从当前位置向下移动一行		   |
     |-----------------------------------------------------------------------------|
     |boolean previous()		  游标从当前位置向上移动一行		   |
     |-----------------------------------------------------------------------------|
     |boolean first()			  查找结果集中的第一行，找到返回true	   |
     |-----------------------------------------------------------------------------|
     |void close()			  关闭ResultSet对象			   |
     |-----------------------------------------------------------------------------|
     |int getInt(int colIndex)		  以int形式获取结果集当前行指定列号值      |
     |-----------------------------------------------------------------------------|
     |int getInt(String colName)	  以int形式获取结果集当前行指定列名值      |
     |-----------------------------------------------------------------------------|
     |float getFloat(int colIndex)	  以float形式获取结果集当前行指定列号值    |
     |-----------------------------------------------------------------------------|
     |float getFloat(String colName)	  以float形式获取结果集当前行指定列名值    |
     |-----------------------------------------------------------------------------|
     |String getString(int colIndex)	  以String 形式获取结果集当前行指定列号值  |
     |-----------------------------------------------------------------------------|
     |String getString(String colName)    以String形式获取结果集当前行指定列名值   |
      -----------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------
【第十八章】DAO设计模式
      DAO(Data Access Object,数据访问对象)是属于J2EE体系架构中数据层的操作,主要的功能是用于进行数据操作的,使用   DAO设计模式可以简化大量代码，增强程序的可移植性。
 ·数据持久化
       将程序中的数据在瞬时状态和持久状态间转换的机制即为数据持久化
   实现方式：
	     数据库
	     普通文件
	     XML文件

 ·程序代码高耦合的影响：
	1.可读性差
	2.不利于后期修改和维护
	3.不利于代码复用

 ·Dao设计模式组成部分
	实体类
	工具类
	Dao接口
	Dao接口实现类
	Service业务逻辑接口
	Service业务逻辑接口实现类

 ·Dao设计模式的优势：
	1.隔离了数据访问代码和业务逻辑代码
	2.隔离了不同数据库实现

 ·包命名规范
	实体类包：com.公司名.项目名.entity
	DAO接口类包：com.公司名.项目名.dao
	DAO接口实现类包：com.公司名.项目名.impl
	Service接口类包：com.公司名.项目名.service
	Seriice接口实现类包：com.公司名.项目名.service.impl

 ·软件系统三层架构
	 用户请求
	    ↓
	  表示层（UI）
	    ↓  
	业务逻辑层（BLL）
	    ↓  
	数据访问层（DAL）
	    ↓
	  数据库

   ·分层原则
	封装性原则：每个层次向外公开接口，但是隐藏内部细节
	顺序访问原则：下一层为上一层服务，但不使用上层的服务分层结构中，不同层之间通过实体类传输数据

----------------------------------------------------------------------------------------------------------------------
【第十九章】File文件、I/O流
  ·File
    文件可认为是相关记录或放在一起的数据的集合
   ·File类常用方法
	 -------------------------------------------------------------------------------------
	|    	   方法名称				      说      明		      |
	|-------------------------------------------------------------------------------------|
	|boolean exists( )		判断文件或目录是否存在				      |
	|boolean isFile( )		判断是否是文件					      |
	|boolean isHidden( )		判断是否是一个隐藏的文件			      |
	|boolean isDirectory( )		判断是否是目录					      |
	|String getPath( )		返回此对象表示的文件的相对路径名		      |
	|String getAbsolutePath( )	返回此对象表示的文件的绝对路径名		      |
	|String getName( )		返回此对象表示的文件或目录的名称		      |
	|boolean setReadOnly()		设置文件或目录为只读				      |
	|boolean delete( )		删除此对象指定的文件或目录			      |
	|boolean createNewFile( )	新建文件					      |
	|boolean mkdir()		创建一个目录					      |
	|boolean mkdirs()		创建多个目录					      |
	|long lastModified()		返回文件最后一次修改的时间			      |
	|long  length()			返回文件的长度，单位为字节(b), 如果文件不存在则返回0L |
	 -------------------------------------------------------------------------------------

  ·时间与日期
   //创建一个时间对象
	Date date = new Date();
   //创建一个日期格式
	SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
   //将字符串转换为Date对象(日期)
	Date d=sdf.parse("2018-03-26");
   //将Date对象转换为字符串
	String s=sdf.format(d);
   //获取当前系统时间
	Calendar time=Calendar.getInstance();
   //获取一周中的第几天（星期）
	System.out.println(time.get(Calendar.DAY_OF_WEEK));

 ·I/O流
   一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据以先进先出方式发送。

  ·流的分类
    	按流向分为:输入流、输出流
	按处理的数据单元分为:字节流、字符流

  ·使用I/O流的步骤
	1.引入相关的类
	2.创建输入/输出流对象
	3.读取/写入文本文件的数据
	4.关闭相关流的对象

  ·字节输入流(FileInputStream)常用方法
	int read(): 读取一个字节的数据，并将字节的值作为int类型返回(0-255之间的一个值)。如果未读出字节则返回-1
	int read(byte[] b): 一次读取数组长度的字节
	int read(byte[] b,int off,int len): 在当前字节数组中以off开始，读取len个字节到byte数组中
	int available(): 数据流中的字节数量
	void  close(): 关闭输入流对象，释放资源
    常用构造方法
	FileInputStream(File file)
	FileInputStream(String name)

  ·字节输出流(FileOutputStream)常用方法
	void  write(int n): 向输入流中写入一个字节
	void  write(byte[] b): 一次写入数组长度的字节
	void  write(byte[] b,int off,int len): 在当前字节数组中以off开始，读取len个字节到byte数组中
	void  flush(): 清空缓冲区
	void  close(): 关闭对象释放资源
    常用构造方法
	FileOutputStream(File file) 
	FileOutputStream(String name) 
	FileOutputStream(File file, boolean append)
	FileOutputStream(String name, boolean append)
    注意：
	1、前两种构造方法在向文件写数据时将覆盖文件中原有的内容
	2、创建FileOutputStream实例时，如果相应的文件不存在，则会自动创建一个空的文件

  ·字符输入流(FileReader)常用方法
	int read(): 读取一个字符的数据，未读出字符返回-1。 
	read(char[] c,int off,int len): 在当前字符数组中以off开始，读取len个字符到byte数组中
	void  close(): 关闭对象释放资源

  ·字符输入流(BufferedReader)特有方法
	String readLine(): 读取一个文本行,如果已到达流末尾返回null
    常用构造方法
	 BufferedReader(Reader in)

  ·字符输出流(FileWriter)常用方法
	void  write(int n): 写入单个字符
	void  write(char[] c): 写入字符数组
	void  write(char[] cbuf, int off, int len):在当前字符数组中以off开始，读取len个字符到byte数组中
	void  close(): 关闭对象释放资源
	writer  append(char c): 将指定字符添加到此writer
	void  flush(): 清空缓冲区
    常用构造方法
	BufferedReader(Writer out)

  ·数据输入流(DataInputStream)常用方法
	int read() :读取数据流（二进制）
	void  close() :关闭对象释放资源

  ·数据输出流(DataOutputStream)常用方法
	void  write(int n): 写入单个字符
	void  write(char[] c): 写入字符数组
	void  write(char[] cbuf, int off, int len): 在当前字符数组中以off开始，读取len个字符到byte数组中
	void  close(): 关闭对象释放资源
	void  flush(): 清空缓冲区

  ·序列化对象(ObjectOutputStream)常用方法
	void writeObject(Object obj): 将指定的对象写入ObjectOutputStream
	void  close(): 关闭对象释放资源
	void  flush(): 清空缓冲区

  ·反序列化对象(ObjectInputStream)常用方法
	Object  readObject(): 从ObjectInputStream读取对象
	void  close(): 关闭对象释放资源
	void  flush(): 清空缓冲区
    注意：
	1.一个类的对象要想序列化成功，实体类必须实现Serializable接口
	2.对于一个实体类，不想将所有的属性都进行序列化，有专门的关键字transient
	如：private transient String name;

----------------------------------------------------------------------------------------------------------------------【第二十章】多线程
 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在,它必须是进程的一部分。
 线程：如果一个进程中同时运行了多个进程，用来完成不同的工作。多个线程交替占用CPU资源，而非真正的并行执行。
 线程调度：指按照特定机制为多个线程分配CPU的使用权
 主线程：main()方法即为主线程入口，产生其他子线程的线程，必须最后完成执行，因为他执行各种关闭动作。
 多线程应用：如一个浏览器同时下载多个图片，一个服务器同时处理多个请求
 多线程好处：
	1、充分利用CPU资源
	2、简化编程模型
	3、带来良好的用户体验
	4、多个线程共享同一进程的资源

 线程的状态：
	创建状态→start→就绪状态→运行状态→终止 or 阻塞（如果阻塞，阻塞解除→就绪状态）

 ·线程创建方法：
	·通过继承java.lang.Thread类
		1、创建类并继承 Thread 类
		public class MyThread extends Thread(){};
		2、重写父类的 run() 方法
		public void run(){
			//线程执行的代码
		}
		3、创建线程对象，调用 start() 方法启动线程
		public class Test {
			public static void main(String[] args) {
				// 创建线程对象
				MyThread myThread =new MyThread();
				// 启动线程
				myThread.start();
			}
		}

	·通过实现java.lang.Runnable接口（推荐）
		1、创建类并实现Runnable接口
		public class MyThread implements Runnable{};
	 	2、实现 run() 方法
		public void run() {
			//线程执行的代码
		}
		3、创建Runnable的实现类对象，创建线程对象并传入参数，调用 start() 方法启动线程
		public class Test {
			public static void main(String[] args) {
				// 创建Runnable的实现类对象
				MyThread myThread=new MyThread();
				// 创建线程对象并传入参数
				Thread thread = new Thread(myThread,"线程A");
				// 启动线程
				thread.start();
			}
		}

 ·常用构造函数
	Thread() 分配新的 Thread 对象
	Thread(Runnable target) 分配新的 Thread 对象
	Thread(Runnable target, String name) 分配新的 Thread 对象,并设置线程名称

 ·常用方法
	 --------------------------------------------------------------------------------------------------
	|  返回值类型		方法名				说明	 				   |
	|--------------------------------------------------------------------------------------------------|
	|void 		start()				启动线程					   |
	|void		setName(String name)		更改线程的名称					   |
 	|String 	getName() 			返回线程的名称				   	   | 
	|void 		setPriority(int newPriority)	更改线程的优先级，优先级由1-10,最低为1,默认为5	   |
	|int 		getPriority() 			返回线程的优先级				   |
	|void 		join()				等待该线程终止 （强制运行）	 		   |
	|void 		join(long millis)		等待该线程终止的时间最长为 millis 毫秒		   |
	|static void	sleep(long millis)		在指定的毫秒数内让当前正在执行的线程休眠(暂停执行) |
	|static void 	yield()				暂停当前正在执行的线程对象，并执行其他线程	   |
	|void 		interrupt() 			中断线程					   |
	|boolean 	isAlive() 			测试线程是否处于活动状态			   |
	|static boolean interrupted() 			测试当前线程是否已经中断			   |
	|static Thread 	Thread.currentThread()		返回当前线程对象 				   |
	 --------------------------------------------------------------------------------------------------

 ·线程同步
   多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题。
   synchronized同步块是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其   他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。

  ·同步方法
    synchronized就是为当前线程声明的一个锁，无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象
    语法：
	方法一：
	访问修饰符 synchronized 返回类型 方法名(参数列表){
		//需要同步的代码
	}
	方法二：
	synchronized 访问修饰符 返回类型 方法名(参数列表){
		//需要同步的代码
	}

  ·同步代码块
    语法：
	synchronized(syncObject){//syncObject为需要同步的对象，通常为this
		//需要同步的代码
	}

 ·线程安全的类型
	 -------------------------------------------------------------------------------------
	| 		|     方法是否同步	|	使用场景	|	效率比较      |
	|---------------|-----------------------|-----------------------|---------------------|
	|   线程安全	|	  是		|  多线程并发共享资源	|	   低	      |
	|---------------|-----------------------|-----------------------|---------------------|
	|  非线程安全	|	  否		|  	单线程		|	   高	      |
	 -------------------------------------------------------------------------------------

 ·常见类型对比
   Hashtable和HashMap：
	·Hashtable
		1.继承关系，实现了Map接口，Hashtable继承Dictionary类
		2.线程安全，效率较低
		3.键和值都不允许为null
	·HashMap
		1.继承关系，实现了Map接口，HashMap继承AbstractMap类
		2.线程安全，效率较高
		3.键和值都允许为null

----------------------------------------------------------------------------------------------------------------------
【第二十一章】Socket网络编程
     Socket(套接字)是连接运行在网络上的两个程序间的双向通信的端点，客户端(Client)程序创建一个套接字,并尝试连接   服务器(Server)的套接字,使用Socket通信时需要借助数据流来完成数据传递工作。
 ·Socket通信模型
     目前较为流行的网络编程模型是客户端/服务端(C/S)通信模式，客户进程向服务器进程发出要求某种服务的请求，服务器  进程响应该请求。
		 -----------------------------------------
		| Socket客户端		ServerSocket服务端|
		|-----------------------------------------|
	     	|OutputStream	 →	 InputStream	  |
		|InputStream	 ←	 OutputStream	  |
		 -----------------------------------------

 ·基于TCP协议的Socket编程
   TCP(传输控制协议)：面向连接的，可靠的，传输速度慢，基于字节流的传输协议
	·创建TCP服务端步骤
		// 1.创建ServerSocket对象,并设置端口号
		ServerSocket serverSocket = new ServerSocket(8888);

		// 2. 调用accept()方法接受客户端请求
		Socket socket = serverSocket.accept();

		// 3. 从Socket中获取I/O流
		// 从Socket中获取输入流，用来读取客户端发送过来的数据
		InputStream is = socket.getInputStream();
		InputStreamReader isr = new InputStreamReader(is);
		BufferedReader br = new BufferedReader(isr);
		StringBuffer sb = new StringBuffer();

		// 从Socket中获取输出流，用来写入客户端发送过来的数据
		OutputStream os = socket.getOutputStream();
		OutputStreamWriter osw = new OutputStreamWriter(os);
		BufferedWriter bw = new BufferedWriter(osw);

		// 4. 对I/O流进行读写操作，完成与客户端的交互
		while (true) {
			String str = br.readLine();
			if (str == null) {
				break;
			}
			sb.append(str);
		}
		System.out.println("这里是服务端，获取客户端的内容如下:\n" + sb.toString());
		// 禁用此套接字的输入流
		socket.shutdownInput();
		// 数据接收成功，回复客户端
		bw.write("嗯，你好,我是服务端，我收到了你的消息！");

		// 5. 关闭I/O流和Socket
		bw.close();
		osw.close();
		os.close();
		br.close();
		isr.close();
		is.close();
		socket.close();
		serverSocket.close();

	·创建TCP客户端步骤
		// 1. 创建一个Socket对象,并设置指定主机地址和端口号
		Socket socket = new Socket("127.0.0.1", 8888);

		// 2. 从Socket中获取I/O流
		// 从Socket中获取输入流，用来读取服务端发送过来的数据
		OutputStream os = socket.getOutputStream();

		// 3. 从Socket中获取输出流，用来写入服务端发送过来的数据
		InputStream is = socket.getInputStream();
		InputStreamReader isr = new InputStreamReader(is);
		BufferedReader br = new BufferedReader(isr);
		StringBuffer sb = new StringBuffer();

		// 3. 对I/O流进行读写操作，完成与服务端的交互
		String str = "你好，我是客户端！收到请回复？";
		os.write(str.getBytes());
		socket.shutdownOutput();

		// 4. 数据发送成功，接收服务端的回复内容
		while (true) {
			String strRead = br.readLine();
			if (strRead == null) {
				break;
			}
			sb.append(strRead);
		}
		System.out.println("这里是客户端，获取服务端的内容如下:\n" + sb.toString());

		// 5. 关闭I/O流和Socket
		br.close();
		isr.close();
		is.close();
		os.close();
		socket.close();

	注：客户端和服务端进行数据传输时，客户端的输入流对应服务端的输出流，客户端的输出流对应服务端的输入流。

 ·ServerSocket类常用构造方法
	ServerSocket() 创建非绑定服务器套接字
	ServerSocket(int port) 创建绑定到特定端口的服务器套接字

 ·ServerSocket类常用方法
   服务器应用程序通过使用java.net.ServerSocket类以获取一个端口,并且侦听客户端请求。
	 --------------------------------------------------------------------------------------------------
	|  返回值类型		方法名				说明	 				   |
	|--------------------------------------------------------------------------------------------------|
	|Socket 		accept()		侦听并接受到此套接字的连接			   |
	 --------------------------------------------------------------------------------------------------

 ·Socket类常用构造方法
	Socket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号

 ·Socket类常用方法
   java.net.Socket类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个Socket对象通过实例化而，服务器获     得一个Socket对象则通过accept()方法的返回值。 
	 --------------------------------------------------------------------------------------------------
	|  返回值类型		方法名				说明	 				   |
	|--------------------------------------------------------------------------------------------------|
	|InetAddress 	getInetAddress()	返回套接字连接的地址					   |
	|int 		getPort()		返回此套接字连接到的远程端口				   |
	|int 		getLocalPort()		返回此套接字绑定到的本地端口				   |
	|InputStream 	getInputStream()	返回此套接字的输入流					   |
	|OutputStream 	getOutputStream()	返回此套接字的输出流					   |
	|void 		shutdownInput()		禁用此套接字的输入流					   |			|void 		shutdownOutput()	禁用此套接字的输出流					   |
	|void 		close()			关闭此套接字						   |
	 --------------------------------------------------------------------------------------------------

 ·InetAddress类常用方法
   这个类表示互联网协议(IP)地址。
	 --------------------------------------------------------------------------------------------------
	|  返回值类型		方法名				说明	 				   |
	|--------------------------------------------------------------------------------------------------|
	|String 		getHostAddress() 	返回IP地址字符串				   |
	|String 		getHostName() 		返回此IP地址的主机名				   |
	|static InetAddress 	getLocalHost()		返回本地主机					   |
	 --------------------------------------------------------------------------------------------------

 ·基于UDP协议的Socket编程
   UDP协议(用户数据报协议)：无连接的协议，不可靠，传输快，在传输数据之前，客户端和服务器无需建立和维护连接
	·创建发送端
		// 1. 接收要发送的内容
		Scanner input=new Scanner(System.in);
		System.out.println("请输入要发送的内容：");
		String str = input.next();

		// 2. 创建DatagramSocket对象，用来发送数据报
		DatagramSocket ds = new DatagramSocket();

		// 3. 将数据进行DatagramPacket包的封装，必须要指定目的地地址和端口
		DatagramPacket dp = new DatagramPacket(str.getBytes(), str.length(),InetAddress.getByName			("localhost"), 8888);

		// 4. 通过DatagramSocket对象的send方法将该报发出
		ds.send(dp);

		// 5. 将DatagramSocket关闭
		ds.close();

	·创建接收端
		// 1. 创建DatagramSocket对象并设置端口号，用来接收数据报
		DatagramSocket ds=new DatagramSocket(8888);

		// 2. 创建缓冲区
		byte[] bytes = new byte[1048];

		// 3. 创建DatagramPacket对象从缓冲区获取数据，并打包
		DatagramPacket dp = new DatagramPacket(bytes, bytes.length);

		// 4. 通过DatagramSocket对象的receive方法将数据存入数据报中
		ds.receive(dp);

		// 5. 从数据报中获取数据
		String str=new String(dp.getData());

		// 6. 显示接收的数据
		System.out.println("接收到的数据是："+str);

		// 7. 将socket关闭
		ds.close();

 ·DatagramPacket类常用构造方法
	DatagramPacket(byte[] buf, int length) 构造 DatagramPacket，用来接收长度为 length 的数据包
	DatagramPacket(byte[] buf, int length, SocketAddress address) 构造数据报包，用来将长度为 length 的包发		送到指定主机上的指定端口号
	DatagramPacket(byte[] buf, int length, InetAddress address, int port) 构造数据报包，用来将长度为 length 	的包发送到指定主机上的指定端口号

 ·DatagramPacket类常用方法
   DatagramPacket类表示数据报包，封装了数据报的数据、数据长度、目标地址和目标端口
	 ---------------------------------------------------------------------------------------
	|  返回值类型		方法名					说明 			|
	|---------------------------------------------------------------------------------------|
	|byte[]			getData()		返回数据缓冲区 				|
	|int			getLength()		返回将要发送或接收到的数据的长度 	|
	|int			getPort()		返回某台远程主机的端口号		|
	 ---------------------------------------------------------------------------------------

 ·DatagramSocket类常用构造方法
	DatagramSocket() 构造数据报套接字并将其绑定到本地主机上任何可用的端口
	DatagramSocket(int port) 创建数据报套接字并将其绑定到本地主机上的指定端口
	DatagramSocket(int port, InetAddress laddr) 创建数据报套接字，将其绑定到指定的本地地址

 ·DatagramSocket类常用方法
   DatagramSocket类表示用来发送和接收DatagramPacke对象封装好的数据报包的套接字
	 -----------------------------------------------------------------------------------------
	|  返回值类型		方法名					说明 			  |
	|-----------------------------------------------------------------------------------------|
	|void 		bind(SocketAddress addr)	将此 DatagramSocket 绑定到特定的地址和端口|
	|int 		getPort()			返回此套接返回此套接字的端口		  |
	|void 		receive(DatagramPacket p)	从此套接字接收数据报包		 	  |
	|void 		send(DatagramPacket p)		从此套接字发送数据报包 			  |
	|void 		close()				关闭此数据报套接字			  |
	 -----------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------
				     	Copyright © 曹帅华 All Rights Reserved
